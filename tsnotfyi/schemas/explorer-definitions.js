// Explorer State Definitions - The Central Orchestrator
// Pure type definitions for shared lexicon - no validation, just clarity

const { z } = require('zod');
const { AnyTrack } = require('./track-definitions');
const { Direction, ExplorerDirections } = require('./direction-definitions');
const { CardCollection } = require('./card-definitions');

// ==================== EXPLORER CORE DATA (SERVER-GENERATED) ====================

// The core explorer data generated by the server - immutable on client
const ExplorerDataCore = z.object({
  // Central exploration data (from DriftAudioMixer.getComprehensiveExplorerData)
  directions: z.record(z.string(), Direction), // All available directions keyed by direction key
  
  // Current recommendation
  nextTrack: z.object({
    directionKey: z.string(),               // Which direction was selected
    direction: z.string(),                  // Direction name (e.g., "faster")
    track: AnyTrack,                        // The recommended track
  }).optional(),
  
  // Metadata about the exploration
  diversityMetrics: z.object({
    overall: z.number().optional(),         // Overall diversity score
    byDomain: z.record(z.string(), z.number()).optional(), // Per-domain diversity
    trackSpread: z.number().optional(),     // How spread out tracks are
  }).optional(),
  
  // Context information
  resolution: z.enum(['microscope', 'magnifying_glass', 'binoculars']), // Current zoom level
  centerTrack: AnyTrack.optional(),         // Track at center of exploration
  generatedAt: z.date(),                    // When this data was generated
  cacheKey: z.string().optional(),          // Cache identifier (trackId_resolution)
});

// ==================== EXPLORER UI STATE (CLIENT-MANAGED) ====================

// Client-side state that manages user interaction with explorer data
const ExplorerUIState = z.object({
  // Current selection state
  selectedIdentifier: z.string().optional(), // Currently selected track ID
  selectedDirectionKey: z.string().optional(), // Currently selected direction
  
  // Stack navigation state
  stackIndex: z.number().default(0),        // Current position in selected direction's stack
  remainingCounts: z.record(z.string(), z.number()).default({}), // Remaining tracks per direction
  
  // Direction state
  usingOppositeDirection: z.boolean().default(false), // Whether using opposite polarity
  baseDirectionKey: z.string().optional(),  // Base direction before polarity flip
  serverNextDirection: z.string().optional(), // Server's recommended direction
  
  // Track state tracking
  latestCurrentTrack: AnyTrack.optional(),  // Last known current track
  previousNextTrack: AnyTrack.optional(),   // Previous next track
  serverNextTrack: AnyTrack.optional(),     // Server's recommended next track
  
  // UI interaction state
  journeyMode: z.boolean().default(false),  // Whether in journey exploration mode
  explorationLocked: z.boolean().default(false), // Whether exploration is locked
  autoAdvance: z.boolean().default(true),   // Whether to auto-advance tracks
});

// ==================== EXPLORER CACHES (PERFORMANCE) ====================

// Client-side caches for performance and consistency
const ExplorerCaches = z.object({
  // Track metadata cache
  trackMetadataCache: z.record(z.string(), z.object({
    meta: AnyTrack,                         // Cached track metadata
    fetchedAt: z.date(),                    // When it was cached
    source: z.enum(['api', 'sse', 'explorer']), // Where it came from
  })).default({}),
  
  // Track color assignments (for consistent UI)
  trackColorAssignments: z.record(z.string(), z.object({
    variant: z.string(),                    // Color variant (red-variant, green-variant, etc.)
    borderColor: z.string().optional(),     // Computed border color
    glowColor: z.string().optional(),       // Computed glow color
    assignedAt: z.date(),                   // When color was assigned
  })).default({}),
  
  // Direction color cache
  directionColorCache: z.record(z.string(), z.object({
    borderColor: z.string(),
    glowColor: z.string(),
    directionType: z.string(),              // Type used for color computation
    isNegative: z.boolean(),                // Whether direction is negative polarity
  })).default({}),
});

// ==================== EXPLORER SYNCHRONIZATION STATE ====================

// State for managing server-client synchronization
const ExplorerSyncState = z.object({
  // SSE connection state
  lastSSEMessageTime: z.date().optional(), // Last time we got SSE message
  sseConnectionStatus: z.enum(['connected', 'disconnected', 'connecting', 'error']).default('disconnected'),
  missedHeartbeats: z.number().default(0), // Count of missed heartbeats
  
  // Data consistency
  lastExplorerDataUpdate: z.date().optional(), // When explorer data last changed
  lastUIStateUpdate: z.date().optional(),   // When UI state last changed
  pendingServerSync: z.boolean().default(false), // Whether we need to sync with server
  
  // Loading states
  explorerDataLoading: z.boolean().default(false), // Whether loading new explorer data
  trackMetadataLoading: z.set(z.string()).default(new Set()), // Track IDs being loaded
  
  // Error state
  lastError: z.object({
    message: z.string(),
    timestamp: z.date(),
    source: z.enum(['sse', 'api', 'cache', 'validation']),
  }).optional(),
});

// ==================== COMPLETE EXPLORER STATE ====================

// The complete client-side explorer state (window.state)
const CompleteExplorerState = z.object({
  // Core data from server
  latestExplorerData: ExplorerDataCore.optional(), // Current exploration data
  
  // UI interaction state
  uiState: ExplorerUIState,
  
  // Performance caches
  caches: ExplorerCaches,
  
  // Synchronization state
  sync: ExplorerSyncState,
  
  // Card management (UI representation of explorer data)
  cards: CardCollection.optional(),
  
  // Global UI state
  globalUI: z.object({
    windowWidth: z.number().optional(),     // Current window dimensions
    windowHeight: z.number().optional(),
    isMobile: z.boolean().default(false),   // Whether on mobile device
    darkMode: z.boolean().default(false),   // Dark mode preference
    keyboardShortcutsEnabled: z.boolean().default(true),
    
    // Layout state
    layoutType: z.enum(['circular', 'grid', 'force']).default('circular'),
    layoutCenter: z.object({
      x: z.number(),
      y: z.number(),
    }).optional(),
  }).optional(),
});

// ==================== EXPLORER DATA RELATIONSHIPS ====================

// Relationship between explorer data and UI state
const ExplorerRelationships = z.object({
  // Direction-to-Card mappings
  directionCardMappings: z.record(z.string(), z.string()), // directionKey -> cardKey
  
  // Track-to-Card mappings
  trackCardMappings: z.record(z.string(), z.array(z.string())), // trackId -> [cardKey]
  
  // Current focus chain
  focusChain: z.object({
    currentTrack: z.string().optional(),     // Current track ID
    selectedDirection: z.string().optional(), // Selected direction key
    selectedCard: z.string().optional(),     // Selected card key
    nextTrack: z.string().optional(),        // Next track ID
  }),
  
  // State consistency checks
  consistency: z.object({
    explorerDataHash: z.string().optional(), // Hash of current explorer data
    uiStateHash: z.string().optional(),      // Hash of current UI state
    lastConsistencyCheck: z.date().optional(), // When consistency was last checked
    inconsistencies: z.array(z.string()).default([]), // List of detected inconsistencies
  }),
});

// ==================== EXPLORER STATE TRANSITIONS ====================

// State transition definitions for explorer state management
const ExplorerTransitions = z.object({
  // Transition types
  transitionType: z.enum([
    'track_change',        // Current track changed
    'direction_select',    // User selected direction
    'stack_cycle',         // User cycled through stack
    'polarity_flip',       // User flipped direction polarity
    'resolution_change',   // Zoom level changed
    'data_refresh',        // Explorer data refreshed from server
  ]),
  
  // Transition metadata
  triggeredBy: z.enum(['user', 'server', 'auto', 'system']),
  timestamp: z.date(),
  
  // State before/after (for debugging)
  beforeState: z.record(z.any()).optional(),
  afterState: z.record(z.any()).optional(),
});

// ==================== EXPLORER UTILITIES ====================

const ExplorerUtilities = {
  // Check if explorer data is current
  isExplorerDataCurrent: (explorerState) => {
    const data = explorerState.latestExplorerData;
    if (!data) return false;
    
    const age = Date.now() - (data.generatedAt?.getTime() || 0);
    return age < 300000; // 5 minutes
  },
  
  // Get current track from state
  getCurrentTrack: (explorerState) => {
    return explorerState.uiState?.latestCurrentTrack || 
           explorerState.latestExplorerData?.centerTrack;
  },
  
  // Get selected direction with fallback
  getSelectedDirection: (explorerState) => {
    const selectedKey = explorerState.uiState?.selectedDirectionKey;
    if (!selectedKey || !explorerState.latestExplorerData?.directions) return null;
    
    return explorerState.latestExplorerData.directions[selectedKey];
  },
  
  // Get current track in selected direction stack
  getCurrentStackTrack: (explorerState) => {
    const direction = ExplorerUtilities.getSelectedDirection(explorerState);
    if (!direction?.sampleTracks) return null;
    
    const stackIndex = explorerState.uiState?.stackIndex || 0;
    return direction.sampleTracks[stackIndex] || null;
  },
  
  // Check if state needs server sync
  needsServerSync: (explorerState) => {
    return explorerState.sync?.pendingServerSync || 
           explorerState.sync?.sseConnectionStatus === 'disconnected' ||
           !ExplorerUtilities.isExplorerDataCurrent(explorerState);
  },
  
  // Get remaining tracks in current stack
  getRemainingInStack: (explorerState) => {
    const selectedKey = explorerState.uiState?.selectedDirectionKey;
    if (!selectedKey) return 0;
    
    const remaining = explorerState.uiState?.remainingCounts?.[selectedKey];
    return remaining || 0;
  },
  
  // Check state consistency
  checkConsistency: (explorerState) => {
    const issues = [];
    
    // Check if selected direction exists in explorer data
    const selectedKey = explorerState.uiState?.selectedDirectionKey;
    if (selectedKey && !explorerState.latestExplorerData?.directions?.[selectedKey]) {
      issues.push(`Selected direction '${selectedKey}' not found in explorer data`);
    }
    
    // Check if stack index is in bounds
    const direction = ExplorerUtilities.getSelectedDirection(explorerState);
    const stackIndex = explorerState.uiState?.stackIndex || 0;
    if (direction && stackIndex >= (direction.sampleTracks?.length || 0)) {
      issues.push(`Stack index ${stackIndex} out of bounds for direction '${selectedKey}'`);
    }
    
    // Check if selected track exists
    const selectedId = explorerState.uiState?.selectedIdentifier;
    if (selectedId && !explorerState.caches?.trackMetadataCache?.[selectedId]) {
      issues.push(`Selected track '${selectedId}' not in metadata cache`);
    }
    
    return issues;
  }
};

module.exports = {
  // Core data schemas
  ExplorerDataCore,
  ExplorerUIState,
  ExplorerCaches,
  ExplorerSyncState,
  
  // Complete state schemas
  CompleteExplorerState,
  ExplorerRelationships,
  ExplorerTransitions,
  
  // Utilities
  ExplorerUtilities,
};